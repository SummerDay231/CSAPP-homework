# 第一部分 程序结构和执行

## 第二章 信息的表示和处理

### 2.1 信息存储

#### 练习题2.1

A. 0x39A7F8 = $0011|1001|1010|0111|1111|1000_2$

B. $1100|1001|0111|1011_2$ = 0xC97B

C. 0xD5E4C = $1101|0101|1110|0100|1100_2$

D. $10|0110|1110|0111|1011|0101_2$ = 0x26E7D5

#### 练习题2.2

| n      | $2^n$（十进制） | $2^n$（十六进制） |
| ------ | --------------- | ----------------- |
| **9**  | **512**         | **0x200**         |
| **19** | 524288          | 0x80000           |
| 14     | **16384**       | 0x4000            |
| 16     | 65536           | **0x10000**       |
| **17** | 131072          | 0x20000           |
| 5      | **32**          | 0x20              |
| 7      | 128             | **0x80**          |

#### 练习题2.3

| 十进制  | 二进制        | 十六进制 |
| ------- | ------------- | -------- |
| **0**   | **0000 0000** | **0x00** |
| **167** |               |          |
| **62**  |               |          |
| **188** |               |          |
|         | **0011 0111** |          |
|         | **1000 1000** |          |
|         | **1111 0011** |          |
|         |               | **0x52** |
|         |               | **0xAC** |
|         |               | **0xE7** |

#### 练习题2.4

A. 0x503c + 0x8 = 0x5044

B. 0x503c - 0x40 = 0x499c

C. 0x503c + 64 = 0x503c + 0x40 = 0x507c

D. 0x50ea - 0x503c = 0xae

#### 练习题2.5

|      | 小端法   | 大端法   |
| ---- | -------- | -------- |
| A    | 21       | 87       |
| B    | 21 43    | 87 65    |
| C    | 21 43 65 | 87 65 43 |

#### 练习题2.6

A. 0x00359141 = 0000 0000 0011 0101 1001 0001 0100 0001

​	 0x4A564504 = 0100 1010 0101 0110 0100 0101 0000 0100

B. 00000000001**101011001000101000001**

​         010010100**101011001000101000001**00

​	共21位匹配

C. 整数的前11位，浮点数的前九位和后两位

#### 练习题2.7

 61 62 63 64 65 66

#### 练习题2.8

略

#### 练习题2.9

略

#### 练习题2.10

| 步骤  | *x        | *y        |
| ----- | --------- | --------- |
| 初始  | a         | b         |
| 第1步 | a         | b^a       |
| 第2步 | a^(b^a)=b | b^a       |
| 第3步 | b         | (b^a)^b=a |

#### 练习题2.11

略

#### 练习题2.12

A.

```C
x = x & 0x000000FF;
```

B.

```C
x = x ^ 0xFFFFFF00;
```

C.

```C
x = x | 0x000000FF;
```

#### 练习题2.13

```C
int bis(int x, int m) {
    return x | m;
}

int bic(int x, int m) {
    return (x ^ m) & x;
}

int bool_or(int x, int y) {
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y) {
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```

直接看位模式推理更简单。

#### 练习题2.14

略

#### 练习题2.15

```C
!!(x^y)
```

### 2.2 整数表示

#### 练习题2.16

| x        |          | x<<3     |          | x>>2(逻辑) |          | x>>2(算术) |          |
| -------- | -------- | -------- | -------- | ---------- | -------- | ---------- | -------- |
| 十六进制 | 二进制   | 二进制   | 十六进制 | 二进制     | 十六进制 | 二进制     | 十六进制 |
| **0xC3** | 11000011 | 00011000 | 0x18     | 00110000   | 0x30     | 11110000   | 0xF0     |
| **0x75** | 01110101 | 10101000 | 0xA8     | 00011101   | 0x1D     | 00011101   | 0x1D     |
| **0x87** | 10000111 | 00111000 | 0x38     | 00100001   | 0x21     | 11100001   | 0xE1     |
| **0x66** | 01100110 | 00110000 | 0x30     | 00011001   | 0x19     | 00011001   | 0x19     |

#### 练习题2.17

略

#### 练习题2.18

略

#### 练习题2.19

略

#### 练习题2.20

略

#### 练习题2.21

略

#### 练习题2.22

略

#### 练习题2.23

A.

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |

B.

取word最后八位，前面24位置0（fun1）或者根据后八位最高位置0或1（fun2）

#### 练习题2.24

| 十六进制 |        | 无符号 |        | 补码   |        |
| -------- | ------ | ------ | ------ | ------ | ------ |
| 原始值   | 截断值 | 原始值 | 截断值 | 原始值 | 截断值 |
| 0        | 0      | 0      | 0      | 0      | 0      |
| 2        | 2      | 2      | 2      | 2      | 2      |
| 9        | 1      | 9      | 1      | -7     | 1      |
| B        | 3      | 11     | 3      | -5     | 3      |
| F        | 7      | 15     | 7      | -1     | -1     |

#### 练习题2.25

略

#### 练习题2.26

略

### 2.3 整数运算

#### 练习题2.27

```C
int uadd_ok(unsigned x, unsigned y) {
    unsigned result = x + y;
    return x < result;
}
```

#### 练习题2.28

略

#### 练习题2.29

略

#### 练习题2.30

```c
int tadd_ok(int x, int y) {
    int result = x + y;
    return !((x>0&&y>0&&result<=0)||(x<0&&y<0&&result>=0));
}
```

#### 练习题2.31

略

#### 练习题2.32

理论上是正确的，但是由于表示范围的不对称，-TMin = TMin，所以y=TMin时要单独处理

#### 练习题2.33

略

#### 练习题2.34

| 模式   | x      | y      | x*y       | 截断的x*y |
| ------ | ------ | ------ | --------- | --------- |
| 无符号 | 100=4  | 101=5  | 10100=20  | 100=4     |
| 补码   | 100=-4 | 101=-3 | 01100=12  | 100=-4    |
| 无符号 | 010=2  | 111=7  | 01110=14  | 110=6     |
| 补码   | 010=2  | 111=-1 | 11110=-2  | 110=-2    |
| 无符号 | 110=6  | 110=6  | 100100=36 | 100=4     |
| 补码   | 110=-2 | 110=-2 | 000100=4  | 100=4     |

#### 练习题2.35

略

#### 练习题2.36

略

#### 练习题2.37 

略

#### 练习题2.38

a*($2^k\pm 1)$或a\*$2^k$

#### 练习题2.39

x<<(n+1) = 0

#### 练习题2.40

| K          | 移位 | 加减法 | 表达式                           |
| ---------- | ---- | ------ | -------------------------------- |
| 6(110)     | 2    | 1      | (x<<2)+(x<<1) or (x<<3) - (x<<1) |
| 31(11111)  | 1    | 1      | (x<<5)-x                         |
| -6(2 - 8)  | 2    | 1      | (x<<1)-(x<<3)                    |
| 55(110111) | 2    | 2      | (x<<6)-(x<<3)-x                  |

#### 练习题2.41

略

==练习2.42-2.44==

### 2.4 浮点数

#### 练习题2.45

略

#### 练习题2.46

A. 0.00000000000000000000000[1100]..

B.0.1-x = 0.0[0011].. * $2^{-20}$ = 9.537e-8

C. x = 0.099999905 s

运行了100h，实际运行了100h/x s = 3600003tick

差值为0.343s

D. $\Delta t \vdot v$ = 686m

#### 练习题2.47

| 位      | e    | E    | $2^E$ | f    | M    | $2^E \times M$ | V    | 十进制 |
| ------- | ---- | ---- | ----- | ---- | ---- | -------------- | ---- | ------ |
| 0 00 00 | 0    | 0    | 1     | 0/4  | 0/4  | 0/4            | 0/4  | 0      |
| 0 00 01 | 0    | 0    | 1     | 1/4  | 1/4  | 1/4            | 1/4  | 0.25   |
| 0 00 10 | 0    | 0    | 1     | 2/4  | 2/4  | 2/4            | 2/4  | 0.5    |
| 0 00 11 | 0    | 0    | 1     | 3/4  | 3/4  | 3/4            | 3/4  | 0.75   |
| 0 01 00 | 1    | 0    | 1     | 0/4  | 4/4  | 4/4            | 1    | 1      |
| 0 01 01 | 1    | 0    | 1     | 1/4  | 5/4  | 5/4            | 5/4  | 1.25   |
| 0 01 10 | 1    | 0    | 1     | 2/4  | 6/4  | 6/4            | 3/2  | 1.5    |
| 0 01 11 | 1    | 0    | 1     | 3/4  | 7/4  | 7/4            | 7/4  | 1.75   |
| 0 10 00 | 2    | 1    | 2     | 0/4  | 4/4  | 8/4            | 2    | 2      |
| 0 10 01 | 2    | 1    | 2     | 1/4  | 5/4  | 10/4           | 5/2  | 2.5    |
| 0 10 10 | 2    | 1    | 2     | 2/4  | 6/4  | 12/4           | 3    | 3      |
| 0 10 11 | 2    | 1    | 2     | 3/4  | 7/4  | 14/4           | 7/2  | 3.5    |
| 0 11 00 | -    | -    | -     | -    | -    | -              |      | -      |
| 0 11 01 | -    | -    | -     | -    | -    | -              |      | -      |
| 0 11 10 | -    | -    | -     | -    | -    | -              |      | -      |
| 0 11 11 | -    | -    | -     | -    | -    | -              |      | -      |

#### 练习题2.48

3510593 = 0000 0000 001**1 0101 1001 0001 0100 0001** = 1.101011001000101000001 * $2^{21}$

s = 0

E = 21 e = 148 exp = 1001 0100

frac = 1010 1100 1000 1010 0000 100

所以单精度浮点表示为 0100 1010 0**101 0110 0100 0101 0000 01**00 = 0x4A564504

#### 练习题2.49

A.

对于n位小数格式，其最小精度为$2^{-n}$，当阶数E>n时，显然不能精确表示。

能精确表示的最大正整数-1为1.1111...1 * $2^n$ = $(2-2^{-n}) * 2^n$ = $2^{n+1} -1 $

能精确表示的最大正整数为1.00000...0 * $2^{n+1}$ = $2^{n+1}$

则不能精确表示的最小正整数为$2^{n+1}+1$

B.

$2^{24} + 1$ = 16777217

#### 练习题2.50

略

#### 练习题2.51

略

#### 练习题2.52

略

#### 练习题2.53

略

#### 练习题2.54

略

### 家庭作业

#### 2.55

略

#### 2.56

略

#### 2.57

```C
void show_short(short x) {
    show_bytes((byte_pointer) &x, sizeof(short)); 
}

void show_long(long x) {
    show_bytes((byte_pointer) &x, sizeof(long)); 
}

void show_double(double x) {
    show_bytes((byte_pointer) &x, sizeof(double));
}
```

#### 2.58

```C
int is_little_endian() {
    int x = 0xFC;
    byte_pointer start = (byte_pointer) &x;
    if ((int) *start == 0xFC) {
        return 1;
    }
    return 0;
}
```

#### 2.59

```C
int combine(int x, int y) {
    return (x & 0x00FF) | (y >> 8 << 8);
}
```

#### 2.60

```C
unsigned replace_byte(unsigned x, int i, unsigned char b) {
    return (x & ~(0xFF << (i*8))) | (b << (i*8));
}
```

#### 2.61

```C
int a = !(~x);
int b = !x;
int c = !(~(x << (w-8) >> (w-8)));
int d = !(x >> (w-8));
```

#### 2.62

```C
int int_shifts_are_arithmetic() {
    int w = sizeof(int) << 3;
    int x = 0x000000FF;
    return !(~(x << (w-8) >> (w-8)));
}
```

#### 2.63

```C
unsigned srl(unsigned x, int k) {
    unsigned xsra = (int) x >> k;
    int w = sizeof(int) << 3;
    unsigned mask = ~(0xFFFFFFFF << (w-k));
    return xsra & mask;
}

int sra(int x, int k) {
    int xsrl = (unsigned) x >> k;
    int w = sizeof(int) << 3;
    int mask = (-(!!(x & 0x80000000))) << (w-k);
    return xsrl | mask;
}
```

#### 2.64

```C
int any_odd_one(unsigned x) {
    unsigned mask = 0xAAAAAAAA; // 0x55555555 otherwise
    return !!(x & mask);
}
```

#### 2.65

```C
int odd_ones(unsigned x) {
    x = (x >> 16) ^ x;
    x = (x >> 8) ^ x;
    x = (x >> 4) ^ x;
    x = (x >> 2) ^ x;
    x = (x >> 1) ^ x;
    return x & 0x00000001;
}
```

#### 2.66

我的答案（运算符过多）

```C
int leftmost_one(unsigned x) {
    int pos = !!(x >> 16) * 16; // leftmost_one is in 16-31 or 0-15
    pos += !!(x >> (pos + 8)) * 8;
    pos += !!(x >> (pos + 4)) * 4;
    pos += !!(x >> (pos + 2)) * 2;
    pos += !!(x >> (pos + 1));
    return (1 << pos) & x;
}
```

满足要求的答案

```C
int leftmost_one(unsigned x) {
  x |= x >> 1;
  x |= x >> 2;
  x |= x >> 4;
  x |= x >> 8;
  x |= x >> 16;
  return (x >> 1) + (x && 1);
}
```

其核心思想就是用最左侧的1 把右侧（包括最左1位）的2、4、8、16、32位全部置1

#### 2.67

A.

位移数不得大于等于位数

B.

```C
int int_size_is_32() {
    int set_msb = 1 << 31;
    int beyond_msb = set_msb << 1;
    return set_msb && !beyond_msb;
}
```

C.

```C
int int_size_is_32() {
    int set_msb = 1 << 15 << 15 << 1;
    int beyond_msb = set_msb << 1;
    return set_msb && !beyond_msb;
}
```

